<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mines Predictor</title>
    <link rel="stylesheet" href="/main.144a5b0d.css">
    <style>
        :root { --footer-h: 14vmin; }
        body { 
            margin: 0; 
            padding: 0; 
            background: #0a0f1d; 
            font-family: Arial, sans-serif; 
            overflow: hidden; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            height: calc(100vh - var(--footer-h)); 
        }
        
        /* Stage holds frame and outside decorations */
        .stage { 
            position: relative; 
            width: 340px; 
            height: 340px; 
            overflow: visible; 
        }
        
        /* Frame fills the stage - original styling */
        .frame {
            position: absolute; 
            inset: 0;
            background-color: #0a0f1d;
            background-image: url('./cellsFrame.40eb57f7e28f2ca52ad4.png');
            background-position: 50%;
            background-repeat: no-repeat;
            background-size: auto;
            border-radius: 25px;
            box-shadow: 0 -2px 20px rgba(42, 49, 69, .4), 0 4px 54px rgba(42, 49, 69, .2);
            z-index: 1;
            transition: all .5s ease;
            animation: originalFieldAppear 0.8s ease-out forwards;
        }
        
        /* Fallback если рамка не загрузилась */
        .frame::before {
            content: '';
            position: absolute;
            inset: 0;
            border: 2px solid #16cef0;
            border-radius: 25px;
            opacity: 0.3;
            z-index: 0;
        }
        
        /* Дополнительный fallback - рамка как элемент */
        .frame-fallback {
            position: absolute;
            inset: 0;
            background-image: url('./cellsFrame.40eb57f7e28f2ca52ad4.png');
            background-position: 50%;
            background-repeat: no-repeat;
            background-size: auto;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .frame-fallback.loaded {
            opacity: 1;
        }
        
        @keyframes originalFieldAppear {
            0% {
                opacity: 0;
                transform: scale(0.7) translateY(-50px);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05) translateY(-10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        /* Grid strictly inside visible frame area - original grid */
        .grid-container {
            position: absolute; 
            inset: 0;
            display: grid; 
            grid-template-columns: repeat(5, 66px);
            grid-template-rows: repeat(5, 66px);
            gap: 0;
            z-index: 2;
            padding: 10px;
            overflow: hidden;
            animation: gridAppear 1s ease-out 0.3s forwards;
            opacity: 0;
        }
        
        @keyframes gridAppear {
            0% {
                opacity: 0;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* Original empty cell styling */
        .cell { 
            background: transparent;
            border: none; 
            border-radius: 8px;
            align-items: center;
            display: flex;
            justify-content: center;
            z-index: 1;
            overflow: visible;
            cursor: pointer;
            transition: transform .15s ease-in-out;
            position: relative;
        }
        .cell:hover { transform: scale(1.02); }
        
        /* Icon container like original */
        .icon-wrap { 
            width: 100%; 
            height: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            contain: layout paint;
            backface-visibility: hidden;
            transform: translateZ(0);
        }
        .icon-wrap > svg, .icon-wrap > img {
            width: 56px; 
            height: 56px; 
            display: block; 
            pointer-events: none;
        }
        /* Original sizing - no scale */
        .icon-wrap.icon-star { transform: translateZ(0); transform-origin: 50% 50%; }
        .icon-wrap.icon-cross { transform: translateZ(0); transform-origin: 50% 50%; }
        /* Original hover effect */
        .cell:hover .icon-wrap svg {
            height: 62px;
            width: 62px;
            transition: all .3s;
        }
        
        /* Field reveal mask overlay (first open only) — original sizes */
        .cells-board-mask {
          height: 320px;
          left: 15px;
          -webkit-mask-clip: border-box;
          mask-clip: initial;
                  -webkit-mask-image: url(/cells-mask.1a7021b147b7851ffef6.svg);
        mask-image: url(/cells-mask.1a7021b147b7851ffef6.svg);
          -webkit-mask-size: 100% 100%;
          mask-size: 100% 100%;
          position: absolute;
          top: 15px;
          width: 320px;
          z-index: 2;
          pointer-events: none;
        }
        
        .cells-board-mask .animated-highlight {
          background: linear-gradient(180deg, hsla(0, 0%, 100%, 0), hsla(0, 0%, 100%, .4) 98.37%, hsla(0, 0%, 100%, 0));
          height: 74px;
          position: absolute;
          right: 170px;
          top: 50px;
          -webkit-transform: rotate(-60deg);
          transform: rotate(-60deg);
          width: 610px;
          z-index: 3;
          animation: highlightSweep 3s ease-in-out infinite;
        }
        
        @keyframes highlightSweep {
          0% { right: 170px; opacity: 0; }
          15% { opacity: 1; }
          85% { opacity: 1; }
          100% { right: -300px; opacity: 0; }
        }
        
        /* Анимация появления ячеек - оригинальная */
        @keyframes cellAppear {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* Bottom decorative rock below the frame */
        .footer-rock { 
            position: fixed; 
            left: 50%; 
            bottom: 0; 
            transform: translateX(-50%); 
            width: min(96vmin, 96vw); 
            pointer-events: none; 
            z-index: 0; 
        }
    </style>
  </head>
  <body>
    
    <div class="stage">
        <div class="frame">
            <!-- Fallback рамка -->
            <div class="frame-fallback" id="frameFallback"></div>
            
            <div class="cells-board-mask" id="cellsMask">
                <div class="animated-highlight"></div>
            </div>
            <div class="grid-container" id="gameGrid"></div>
        </div>
        <!-- Bottom decorative rock below the frame -->
        <img class="footer-rock" src="./footer.a650de3af39c3672822e.webp" alt="footer"/>
        

    </div>

    <script>
        // Prevent browser zoom
        (function preventZoom(){
          const onKeyDown = (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=' || e.key === '-' || e.key === '_' || e.key === '0')) e.preventDefault();
            if ((e.ctrlKey || e.metaKey) && (e.code === 'NumpadAdd' || e.code === 'NumpadSubtract')) e.preventDefault();
          };
          const onWheel = (e) => { if (e.ctrlKey) e.preventDefault(); };
          window.addEventListener('keydown', onKeyDown, { passive: false });
          window.addEventListener('wheel', onWheel, { passive: false });
        })();

        // Original assets: external animated star and inline cross
        const STAR_URL = './stars.svg';
        const STAR_FALLBACK_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 56 56" preserveAspectRatio="xMidYMid meet" fill="none" style="background: 0px 0px; shape-rendering: geometricPrecision;">\n  <defs>\n    <linearGradient id="Gradient-0_s_i" x1="28.392" y1="0.972" x2="40.632" y2="48.291" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#fba416" stop-opacity="0"></stop>\n      <stop offset="1" stop-color="#fdbb4e" stop-opacity="0.63"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-1_s_i" x1="28.392" y1="0.972" x2="40.633" y2="48.291" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#fdbb4e" stop-opacity="0"></stop>\n      <stop offset="1" stop-color="#fdbb4e" stop-opacity="0.63"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-3_s_i" x1="43.739" y1="37.512" x2="18.526" y2="14.674" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#feffd3" stop-opacity="0.63"></stop>\n      <stop offset="0.219" stop-color="#fafd4e" stop-opacity="0"></stop>\n      <stop offset="0.491" stop-color="#fdff8b" stop-opacity="0.56"></stop>\n      <stop offset="0.733" stop-color="#f7f990"></stop>\n      <stop offset="1" stop-color="#fff" stop-opacity="0"></stop>\n      <stop offset="1" stop-color="#feffb7" stop-opacity="0"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-4_s_i" x1="28.391" y1="14.126" x2="28.026" y2="38.425" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#feffb0"></stop>\n      <stop offset="0.277" stop-color="#fff" stop-opacity="0.51"></stop>\n      <stop offset="1" stop-color="#fafd4e" stop-opacity="0.15"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-5_s_i" x1="27.214" y1="23.393" x2="27.033" y2="32.029" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#fafd4e" stop-opacity="0"></stop>\n      <stop offset="0.732" stop-color="#fafd4e" stop-opacity="0.46"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-6_s_i" x1="24.792" y1="18.563" x2="29.645" y2="23.143" gradientUnits="userSpaceOnUse">\n      <stop offset="0.224" stop-color="#fafd4e" stop-opacity="0.35"></stop>\n      <stop offset="1" stop-color="#fafd4e" stop-opacity="0"></stop>\n    </linearGradient>\n    <linearGradient id="Gradient-7_s_i" x1="0.016" y1="26.376" x2="16.573" y2="26.055" gradientUnits="userSpaceOnUse">\n      <stop offset="0" stop-color="#fff"></stop>\n      <stop offset="1" stop-color="#fff" stop-opacity="0"></stop>\n    </linearGradient>\n    <radialGradient id="Gradient-2_s_i" cx="0" cy="0" r="1" fx="0" fy="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(52.671 -10.467 32.845) scale(31.9369)">\n      <stop offset="0.739" stop-color="#9cb6dd" stop-opacity="0"></stop>\n      <stop offset="0.898" stop-color="#c6f1ff" stop-opacity="0.37"></stop>\n      <stop offset="1" stop-color="#effbff" stop-opacity="0.7"></stop>\n    </radialGradient>\n    <mask id="Mask-1_s_i">\n      <path fill="url(#Gradient-7_s_i)" transform="rotate(30 31.002 3.397)" d="M0 0h16.959v56H0z"></path>\n    </mask>\n  </defs>\n  <style>\n    @keyframes star_t_s_i { 0% { transform: translate(28.3918px, 26.0576px) scale(0, 0) translate(-23.4974px, -22.4547px);} 42.8571% { transform: translate(28.3918px, 26.0576px) scale(1, 1) translate(-23.4974px, -22.4547px);} 71.4285% { transform: translate(28.3918px, 26.0576px) scale(1.15, 1.15) translate(-23.4974px, -22.4547px);} to { transform: translate(28.3918px, 26.0576px) scale(1, 1) translate(-23.4974px, -22.4547px);} }\n    @keyframes a1_t_s_i { 0%, to { transform: translate(23.4966px, 22.4549px); } }\n    @keyframes a0_t_s_i { 0% { transform: scale(1.889498, 1.889498) translate(-28.3911px, -27.0603px);} to { transform: scale(1, 1) translate(-28.3911px, -27.0603px);} }\n    @keyframes a2_t_s_i { 0% { transform: translate(22.2182px, 22.7642px) rotate(145.526246deg) scale(.462454, .462454) translate(-27.1127px, -26.3671px);} to { transform: translate(22.2182px, 22.7642px) rotate(0deg) scale(1, 1) translate(-27.1127px, -26.3671px);} }\n    @keyframes a2_o_s_i { 0% { opacity: 0;} to { opacity: 1; } }\n    @keyframes a3_t_s_i { 0% { transform: translate(18.9293px, 24.3971px) rotate(-53.127557deg) scale(.322292, .322292) translate(-26.7458px, -20.6401px);} to { transform: translate(21.8514px, 17.0372px) rotate(0deg) scale(1, 1) translate(-26.7458px, -20.6401px);} }\n    @keyframes a3_o_s_i { 0% { opacity: 0;} to { opacity: 1; } }\n    @keyframes a4_t_s_i { 0% { transform: translate(-.804393px, 13.4424px) rotate(30deg) translate(-8.47967px, -28px);} 28.5714% { transform: translate(-.804393px, 13.4424px) rotate(30deg) translate(-8.47967px, -28px);} 85.7142%, to { transform: translate(58.8824px, 41.1538px) rotate(30deg) translate(-8.47967px, -28px);} }\n  </style>\n  <g id="star" transform="matrix(0 0 0 0 28.392 26.058)" style="animation: 0.7s linear 0s 1 normal both running star_t_s_i;">\n    <path d="M26.439 4.8c.813-1.595 3.092-1.595 3.905 0l5.7 11.17a2.192 2.192 0 0 0 1.609 1.168l12.385 1.97c1.768.28 2.472 2.448 1.207 3.714l-8.862 8.873a2.193 2.193 0 0 0-.615 1.891l1.955 12.388c.279 1.768-1.565 3.107-3.16 2.295l-11.177-5.686a2.192 2.192 0 0 0-1.989 0L16.22 48.269c-1.595.812-3.439-.527-3.16-2.295l1.955-12.388a2.192 2.192 0 0 0-.615-1.89l-8.862-8.874c-1.265-1.266-.561-3.433 1.207-3.714l12.385-1.97a2.192 2.192 0 0 0 1.609-1.168l5.7-11.17Z" fill="#C22A20" transform="translate(-4.894 -3.603)"></path>\n    <path d="M26.44 4.799c.813-1.595 3.091-1.595 3.905 0l5.7 11.17a2.192 2.192 0 0 0 1.609 1.169l12.385 1.97c1.768.28 2.472 2.447 1.207 3.714l-8.863 8.873a2.192 2.192 0 0 0-.614 1.89l1.954 12.388c.28 1.769-1.564 3.108-3.16 2.296l-11.177-5.687a2.193 2.193 0 0 0-1.988 0L16.22 48.27c-1.596.812-3.44-.527-3.16-2.296l1.954-12.387a2.192 2.192 0 0 0-.614-1.891l-8.863-8.873c-1.265-1.267-.56-3.434 1.207-3.715l12.386-1.969a2.192 2.192 0 0 0 1.608-1.169l5.7-11.17Z" fill="url(#Gradient-1_s_i)" transform="translate(-4.894 -3.603)"></path>\n    <path fill-rule="evenodd" clip-rule="evenodd" d="m35.394 16.302-5.7-11.171c-.542-1.063-2.061-1.063-2.604 0l-5.7 11.17a2.923 2.923 0 0 1-2.145 1.559L6.86 19.829c-1.178.187-1.648 1.632-.804 2.476l8.862 8.873c.66.661.965 1.598.82 2.522l-1.955 12.387c-.186 1.179 1.043 2.072 2.106 1.53l11.178-5.686a2.923 2.923 0 0 1 2.65 0l11.178 5.687c1.064.54 2.292-.352 2.106-1.53L41.047 33.7a2.923 2.923 0 0 1 .82-2.522l8.862-8.873c.843-.844.374-2.289-.805-2.476l-12.385-1.97a2.923 2.923 0 0 1-2.145-1.558Z" fill="url(#Gradient-3_s_i)" transform="translate(-4.894 -3.603)"></path>\n  </g>\n</svg>`;
        const CROSS_URL = './krest.svg';

        class MinesPredictor {
            constructor() {
                this.currentSessionId = null;
                this.prevMap = new Map(); // idx -> 'mine' | 'safe'
                this.pollTimer = null;
                this.freezeUntilMs = 0;
                this.freezeActive = false;
                this.lastRoundSeen = null;
                this.storageKey = 'minesPredictor:lastGrid';
                this.upstreamAvailable = false;
                this.starSvgText = null; // will hold external star svg markup
                this.starTemplate = null;
                this.crossTemplate = null;
                this.ngrokUrl = null; // Будет содержать найденный ngrok URL
                this.init();
            }
            
            // Функция для поиска ngrok URL
            async findNgrokUrl() {
                if (this.ngrokUrl) return this.ngrokUrl;
                
                // Список возможных ngrok доменов
                const possibleUrls = [
                    'https://f5a9ad995f52.ngrok-free.app',
                    'https://7-three-mu.vercel.app', // Vercel fallback
                    'http://localhost:8080' // Локальный fallback
                ];
                
                for (const baseUrl of possibleUrls) {
                    try {
                        const controller = new AbortController();
                        const timeout = setTimeout(() => controller.abort(), 3000);
                        
                        const res = await fetch(`${baseUrl}/mines/debug/state`, { 
                            cache: 'no-store', 
                            signal: controller.signal 
                        });
                        
                        clearTimeout(timeout);
                        
                        if (res.ok) {
                            const data = await res.json();
                            // Проверяем что это действительно данные игры
                            if (data && (data.sessionId || data.bombs || data.safe)) {
                                this.ngrokUrl = baseUrl;
                                console.log(`Найден рабочий URL: ${baseUrl}`);
                                return baseUrl;
                            }
                        }
                    } catch (e) {
                        console.log(`URL ${baseUrl} недоступен:`, e.message);
                    }
                }
                
                // Если ничего не найдено, используем localhost
                this.ngrokUrl = 'http://localhost:8080';
                return this.ngrokUrl;
            }
            
            // Обновленная функция для получения данных
            async fetchGameData() {
                const baseUrl = await this.findNgrokUrl();
                const res = await fetch(`${baseUrl}/mines/debug/state`);
                if (!res.ok) throw new Error('Failed to fetch game data');
                return await res.json();
            }
            
            async init() {
                this.createGrid();
                
                // Проверяем загрузку рамки
                this.checkFrameImage();
                
                // Также пробуем загрузить рамку напрямую
                this.loadFrameDirectly();
                
                // Preload star SVG like original
                try {
                  const resp = await fetch(STAR_URL, { cache: 'force-cache', mode: 'cors' });
                  const raw = resp.ok ? await resp.text() : STAR_FALLBACK_SVG;
                  this.starSvgText = raw || STAR_FALLBACK_SVG;
                } catch(_) { this.starSvgText = STAR_FALLBACK_SVG; }
                this.starTemplate = document.createElement('template');
                this.starTemplate.innerHTML = this.starSvgText || '';
                
                // Preload cross SVG
                try {
                  const crossResp = await fetch(CROSS_URL, { cache: 'force-cache', mode: 'cors' });
                  const crossRaw = crossResp.ok ? await crossResp.text() : '';
                  this.crossSvgText = crossRaw;
                } catch(_) { this.crossSvgText = ''; }
                this.crossTemplate = document.createElement('template');
                this.crossTemplate.innerHTML = this.crossSvgText || '';
                
                // Show mask then start
                const mask = document.getElementById('cellsMask');
                const grid = document.querySelector('.grid-container');
                if (grid) grid.style.opacity = '0';
                if (mask) {
                  mask.style.display = 'block';
                  mask.style.zIndex = '3';
                                                          setTimeout(async () => {
                        mask.style.display = 'none';
                        mask.style.zIndex = '0';
                        if (grid) grid.style.opacity = '1';
                        await this.fetchAndRender();
                        this.startPolling();
                    }, 700);
                } else {
                    await this.fetchAndRender();
                    this.startPolling();
                }
            }
            
            async checkUpstream(timeoutMs = 800) {
              try {
                const baseUrl = await this.findNgrokUrl();
                const controller = new AbortController();
                const t = setTimeout(() => controller.abort(), timeoutMs);
                const res = await fetch(`${baseUrl}/mines/debug/state`, { cache: 'no-store', signal: controller.signal });
                clearTimeout(t);
                this.upstreamAvailable = !!res && res.ok;
              } catch(_) {
                this.upstreamAvailable = false;
              }
              return this.upstreamAvailable;
            }
            
            createGrid() {
                const grid = document.getElementById('gameGrid'); 
                grid.innerHTML = '';
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                    const cell = document.createElement('button');
                    cell.type = 'button';
                        cell.className = 'cell cell-hovered';
                        cell.dataset.row = r; 
                        cell.dataset.col = c;
                    grid.appendChild(cell);
                    }
                }
            }
            
            startPolling() { 
                // Умное обновление - проверяем каждые 2 секунды, но обновляем только при изменениях
                this.pollTimer = setInterval(() => this.checkForUpdates(), 2000); 
            }
            
            checkFrameImage() {
                const frame = document.querySelector('.frame');
                if (!frame) return;
                
                // Пробуем разные пути к рамке
                const framePaths = [
                    './cellsFrame.40eb57f7e28f2ca52ad4.png',
                    './static/media/cellsFrame.40eb57f7e28f2ca52ad4.png',
                    './mines/static/media/cellsFrame.40eb57f7e28f2ca52ad4.png'
                ];
                
                let currentPathIndex = 0;
                
                const tryNextPath = () => {
                    if (currentPathIndex >= framePaths.length) {
                        console.log('Все пути к рамке не работают, используем fallback');
                        frame.style.backgroundImage = 'none';
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        frame.style.backgroundImage = `url("${framePaths[currentPathIndex]}")`;
                        console.log(`Рамка загружена успешно: ${framePaths[currentPathIndex]}`);
                    };
                    img.onerror = () => {
                        console.log(`Ошибка загрузки рамки: ${framePaths[currentPathIndex]}`);
                        currentPathIndex++;
                        tryNextPath();
                    };
                    img.src = framePaths[currentPathIndex];
                };
                
                tryNextPath();
            }
            
            loadFrameDirectly() {
                const frame = document.querySelector('.frame');
                const frameFallback = document.getElementById('frameFallback');
                if (!frame || !frameFallback) return;
                
                // Пробуем загрузить рамку напрямую из текущей папки
                const directPath = './cellsFrame.40eb57f7e28f2ca52ad4.png';
                const img = new Image();
                img.onload = () => {
                    // Скрываем основной фон и показываем fallback
                    frame.style.backgroundImage = 'none';
                    frameFallback.classList.add('loaded');
                    console.log(`Рамка загружена напрямую: ${directPath}`);
                };
                img.onerror = () => {
                    console.log(`Прямая загрузка рамки не удалась: ${directPath}`);
                };
                img.src = directPath;
            }
            
            async checkForUpdates() {
                try {
                    const data = await this.fetchGameData();
                    
                    const sessionId = data.sessionId || null;
                    const lastRound = typeof data.lastRound === 'number' ? data.lastRound : null;
                    
                    // Обновляем ТОЛЬКО при изменении сессии (новая игра)
                    // НЕ обновляем при изменении lastRound (ходы в игре)
                    if (sessionId !== this.currentSessionId) {
                        this.currentSessionId = sessionId;
                        this.lastRoundSeen = lastRound;
                        
                        // Если новая игра, очищаем предыдущее предсказание
                        if (sessionId) {
                            this.clearAll();
                            await this.fetchAndRender();
                        }
                        // Если игра закончилась (sessionId = null), НЕ очищаем предсказание
                        // Оно останется видимым до следующей игры
                    }
                } catch (e) {}
            }
            

            
            idx(r,c){ return r*5+c; }
            
            saveSnapshotToStorage(mapArr){
                try { localStorage.setItem(this.storageKey, JSON.stringify({ map: mapArr, ts: Date.now() })); } catch(_){}
            }
            
            loadSnapshotFromStorageAndRender(){
                try {
                    const raw = localStorage.getItem(this.storageKey);
                    if (!raw) return;
                    const parsed = JSON.parse(raw);
                    const map = Array.isArray(parsed?.map) ? parsed.map : null;
                    if (!map || map.length !== 25) return;
                    // Rehydrate snapshot without changing session bookkeeping
                    for (let r=0;r<5;r++){
                        for (let c=0;c<5;c++){
                            const type = map[this.idx(r,c)];
                            if (type === 'mine' || type === 'safe') this.place(type, r, c, true);
                        }
                    }
                } catch(_){}
            }
            
            place(type, r, c, force = false) {
                const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                if (!cell) return;
                const key = this.idx(r,c);
                // Всегда обновляем содержимое и анимируем
                this.prevMap.set(key, type);
                
                const STAR_INNER = this.starSvgText ? `<div class=\"icon-wrap icon-star\">${this.starSvgText}</div>` : '';
                const CROSS_INNER = this.crossSvgText ? `<div class=\"icon-wrap icon-cross\">${this.crossSvgText}</div>` : '';
                
                if (type === 'mine') {
                    cell.innerHTML = CROSS_INNER;
                } else if (type === 'safe') {
                    cell.innerHTML = STAR_INNER || '';
                } else {
                    cell.innerHTML = '';
                }
                
                // Анимация для ВСЕХ ячеек при каждом обновлении
                cell.style.animation = 'none';
                cell.offsetHeight; // Trigger reflow
                cell.style.animation = 'cellAppear 0.5s ease-out forwards';
            }
            
            clearAll() {
                document.querySelectorAll('.cell').forEach(cell => { 
                    cell.innerHTML = ''; // Clear any existing icons
                    cell.style.animation = ''; // Clear animations
                });
                this.prevMap.clear();
            }
            
            async fetchAndRender() {
                try {
                    const data = await this.fetchGameData();
                    const sessionId = data.sessionId || null;
                    const bombsArr = Array.isArray(data.bombs) ? data.bombs : [];
                    const safeArr = Array.isArray(data.safe) ? data.safe : [];
                    
                    // Если нет активной сессии, оставляем предыдущее предсказание
                    if (!sessionId) {
                        return;
                    }
                    
                    // Если нет данных о бомбах/безопасных ячейках, не обновляем
                    if (bombsArr.length === 0 && safeArr.length === 0) return;
                    
                    const bombs = bombsArr.map(b => `${b.row}:${b.col}`);
                    const bombSet = new Set(bombs);
                    if (!this._renderQueued) {
                        this._renderQueued = true;
                        requestAnimationFrame(() => {
                            this._renderQueued = false;
                            const snapshot = new Array(25);
                            for (let r = 0; r < 5; r++) {
                                for (let c = 0; c < 5; c++) {
                                    const key = `${r}:${c}`;
                                    const type = bombSet.has(key) ? 'mine' : 'safe';
                                    this.place(type, r, c, false);
                                    snapshot[this.idx(r,c)] = type;
                                }
                            }
                            this.saveSnapshotToStorage(snapshot);
                        });
                    }
                } catch (e) {}
            }
        }
        
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => new MinesPredictor());
        } else {
          new MinesPredictor();
        }
    </script>
  </body>
  </html>
